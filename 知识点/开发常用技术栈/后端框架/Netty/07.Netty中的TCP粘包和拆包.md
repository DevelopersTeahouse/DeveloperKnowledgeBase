# Netty 中的 TCP 粘包和拆包

##  TCP 粘包和拆包简介

- 粘包和拆包是 TCP 网络编程中不可避免的，无论是服务端还是客户端，当我们读取或者发送消息的时候，都需要考虑 TCP 底层的粘包/拆包机制
- TCP 是个“流”协议，所谓流，就是没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题

##  TCP 粘包和拆包的四种情况

- 假设客户端发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节数是不确定的，所以可能存在一下四种情况
    - 服务端时分两次收到了两个独立的数据包，分别是 D1 和 D2，所有粘包和拆包
    - 服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，被称为 **TCP 粘包**
    - 如果 D2 的数据包比较大，服务端分两次读取到了两个数据包，第一次读取到完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这被称为 **TCP 拆包**
    - 如果 D1，D2 的数据包都很大，服务端分多次才能将 D1 和 D2 包接收完全，期间发生多次拆包

## TCP 粘包和拆包产生的原因

- 数据从发送方到接收方需要经过操作系统的缓冲区，而造成粘包和拆包的主要原因就是这个缓冲区。粘包可以理解为缓冲区数据堆积，导致多个请求数据粘在一起，而拆包可以理解为发送的数据大于缓冲区，进行拆分处理

## 粘包拆包的解决方法

### 业界解决方案

- 由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下
    - 消息长度固定，累计读取到长度和为定长 LEN 的报文后，就认为读取到了一个完整的信息
    - 将换行符作为消息结束符
    - 将特殊的分隔符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符
    - 通过在消息头中定义长度字段来标识消息的总长度

### Netty 中的粘包和拆包解决方案

- 固定长度的拆包器 `FixedLengthFrameDecoder`，每个应用层数据包都拆分成是固定长度的大小
- 行拆分器 `LineBasedFrameDecoder`，每个应用层数据包，都以换行符作为分隔符，进行分割拆分
    - `ch.pipeline().addLast(new LineBasedFrameDecoder(2048));`
- 分隔符拆分器 `DelimiterBasedFrameDecoder`，每个应用层数据包，都通过自定义的分隔符，进行分割拆分
    - `ByteBuf byteBuf = Unpooled.copiedBuffer("$".getBytes(StandardCharsets.UTF_8));
    - `ch.pipeline().addLast(new DelimiterBasedFrameDecoder(2048, byteBuf));`

ch.pipeline().addLast(new DelimiterBasedFrameDecoder(2048, byteBuf));`

- 基于数据包长度的拆包器 `LengthFieldBasedFrameDecoder`，将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小，拆包。这个拆包器，有一个要求，就是应用层协议中包含数据包的长度